{"type": "root", "attrs": {"type": "node", "context": "sop", "internal": "pack", "icon": "SOP/pack", "tags": "pack, model", "since": "13.0", "verb_since": "16.5", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Pack"], "extent": [0, 9]}, {"type": "summary", "indent": 0, "text": ["Packs geometry into an embedded primitive."], "extent": [119, 169]}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Packing Geometry Into A Single Primitive"], "extent": [169, 216], "body": [{"type": "para", "indent": 0, "text": ["This SOP takes the input geometry and packages it up into an embedded packed primitive."], "extent": [216, 306]}, {"type": "para", "indent": 0, "text": ["An embedded packed primitive stores a copy of the input geometry as part of the primitive\u2019s data.  Any copies of the embedded primitive will share the embedded geometry, potentially with significant memory savings."], "extent": [306, 522]}, {"type": "para", "indent": 0, "text": ["This provides a way of instancing geometry without saving to disk."], "extent": [522, 590]}, {"level": 0, "type": "title", "indent": 0, "text": ["Packed primitives"], "extent": [0, 22]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Overview"], "extent": [44, 59], "body": [{"type": "para", "indent": 0, "text": ["Packed primitives express a procedure to generate geometry at ", {"type": "em", "text": ["render time"]}, ". The purpose is to decrease the amount of memory used when interacting with Houdini by reducing duplication and only loading information when necessary."], "extent": [59, 290]}, {"type": "para", "indent": 0, "text": ["Packed primitives have information about geometry embedded inside of them. The information could be an actual piece of geometry stored in memory, a reference to a part of another piece of geometry, or a file path to geometry stored on disk. Mantra, the Houdini viewport, the solvers, etc, know how to interpret the packed information, and can render/display/work with the geometry efficiently."], "extent": [290, 685]}, {"type": "para", "indent": 0, "text": ["Packed primitives cannot be edited \u2013 they are lightweight references. If you want to edit packed geometry, you have to use the ", {"scheme": "Node", "value": "/nodes/sop/unpack", "type": "link", "text": ["Unpack"], "fullpath": "/nodes/sop/unpack.html"}, " node to extract the part of the geometry you want to edit, modify the geometry, and then optionally repack the geometry using the ", {"scheme": "Node", "value": "/nodes/sop/pack", "type": "link", "text": ["Pack"], "fullpath": "/nodes/sop/pack.html"}, " node."], "extent": [685, 1000]}, {"type": "para", "indent": 0, "text": ["Packed primitives are useful for rendering and simulating heavy geometry or large numbers of copies/instances. Any time the geometry will not change (for example, non-deforming RBD objects), you can benefit from packing the geometry."], "extent": [1000, 1236]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Types of packed primitives"], "extent": [1236, 1269], "body": [{"level": 4, "id": "memory", "container": true, "type": "h", "indent": 0, "text": ["In-memory packed primitives"], "extent": [1269, 1315], "body": [{"type": "para", "indent": 0, "text": ["You get an ", {"type": "em", "text": ["in-memory"]}, " packed primitive by converting geometry to a packed primitive using the ", {"scheme": "Node", "value": "/nodes/sop/pack", "type": "link", "text": ["Pack"], "fullpath": "/nodes/sop/pack.html"}, " geometry node. This creates a packed geometry primitive with an embedded reference to the current version of your geometry in memory. The embedded geometry becomes a single un-editable primitive with a single transform."], "extent": [1315, 1653]}, {"type": "para", "indent": 0, "text": ["The embedded geometry is a reference to content in memory. Copying a packed primitive copies the ", {"type": "em", "text": ["reference"]}, " rather than the geometry itself, so the referenced geometry is shared among all copies of the packed primitive. This is more memory efficient than copying unpacked Houdini geometry, which creates independent duplicates of all points, primitives, attributes, etc."], "extent": [1653, 2026]}, {"type": "para", "indent": 0, "text": ["Copies of packed primitives use less memory, are simpler to transform, and can be drawn more efficiently in the viewport or rendered by Mantra."], "extent": [2026, 2171]}, {"type": "para", "indent": 0, "text": [{"scheme": "Image", "value": "/images/render/mug/packed/BasicPackedPrimUpdate.jpg", "type": "img", "text": ""}], "extent": [2171, 2236]}, {"type": "para", "indent": 0, "text": ["Because the referenced geometry exists in a traditional network, you can easily generate procedural geometry which adapts to your scene, use stamping to generate variations of your packed geometry, or make interactive edits to your geometry while viewing the results live. Essentially, working with in-memory packed primitives is a more interactive and user-friendly version of traditional instancing workflows."], "extent": [2236, 2649]}, {"type": "para", "indent": 0, "text": ["You can unpack individual copies of an in-memory packed primitive in a geometry network to create an actual copy of the referenced geometry. This allows you to generate procedural workflows which are a hybrid of traditional Houdini geometry and packed primitives."], "extent": [2649, 2914]}, {"type": "para", "indent": 0, "text": [{"type": "em", "text": ["Packed"]}, " in this case does not mean compressed or smaller. You are keeping the original geometry in RAM, as well as using a bit of memory for each reference. A single packed primitive is not necessarily more efficient than using the original piece of geometry. The benefit comes from the efficient representation of large numbers of copies that share the referenced geometry. This is important to remember when copy-stamping packed geometry. If every instance of your packed geometry is unique, there are no memory or performance benefits. In fact, this will use more memory than ", {"type": "q", "text": ["real"]}, " geometry, because each packed primitive has its own overhead. (However, it is possible to offset the cost of packing stamped geometry somewhat when there are limited numbers of stamped variations. See the ", {"scheme": "Node", "value": "/nodes/sop/copy", "type": "link", "text": ["Copy SOP"], "fullpath": "/nodes/sop/copy.html"}, "'s ", {"type": "ui", "text": ["Cache Stamping Geometry"]}, " parameter.)"], "extent": [2914, 3775]}]}, {"level": 4, "id": "disk", "container": true, "type": "h", "indent": 0, "text": ["Packed disk primitives"], "extent": [3775, 3813], "body": [{"type": "para", "indent": 0, "text": ["A ", {"type": "em", "text": ["packed disk"]}, " primitive embeds a reference to a file on disk. At display or render time, Mantra/Houdini reads the data from disk rather than keeping it in memory. Some file formats, such as ", {"type": "code", "text": [".bgeo"]}, " and Alembic, make this very efficient by allowing fast random access to their contents. Because packed disk primitives simply load already-generated data from files, they are less dynamic than in-memory packed primitives. The only way to edit a packed disk primitive is to unpack it, copying the file data into memory."], "extent": [3813, 4334]}, {"type": "para", "indent": 0, "text": ["You can load geometry from disk as a packed primitive by using the ", {"scheme": "Node", "value": "/nodes/sop/file", "type": "link", "text": ["File SOP\u2019s"], "fullpath": "/nodes/sop/file.html"}, " ", {"type": "ui", "text": ["Load"]}, " parameter set to ", {"type": "ui", "text": ["Packed Disk Primitive"]}, "."], "extent": [4334, 4482]}, {"type": "para", "indent": 0, "text": ["A packed disk primitive is similar to an in-memory packed primitive in that the embedded geometry appears as a single un-editable primitive with a single transform. Much like in-memory packed primitives, a packed disk primitive is an excellent choice for efficiently creating copies of geometry in the viewport and in Mantra. Copying a packed disk primitive copies the ", {"type": "em", "text": ["reference"]}, " to the disk file. The viewport does not copy the geometry for each instance, but simply draws the same data multiple times with different transforms. The viewport can also draw a much simpler representation of the referenced geometry, such as a point cloud or bounding box."], "extent": [4482, 5138]}, {"type": "para", "indent": 0, "text": [{"scheme": "Image", "value": "/images/render/mug/packed/PackedVisualization.jpg", "type": "img", "text": ""}], "extent": [5138, 5197]}, {"type": "para", "indent": 0, "text": ["Like Houdini, Mantra can ", {"type": "q", "text": ["stream"]}, " the data from the disk file as needed, instead of copying the data into memory. This reduces Mantra\u2019s memory usage. For in-memory geometry, Houdini writes the entire geometry into the ", {"scheme": null, "value": "/render/ifd_workflows", "type": "link", "text": ["IFD file"], "fullpath": "/render/ifd_workflows.html"}, " (the scene description file it sends to Mantra). For packed disk primitives, on the other hand, Houdini writes the ", {"type": "em", "text": ["reference"]}, " to the file on disk, making IFDs smaller on disk and much faster to generate for very large/complex scenes."], "extent": [5197, 5684]}, {"type": "para", "indent": 0, "text": ["Packed disk primitives are ideal for scene assembly, especially for static background objects. Their small memory usage at render time also makes them very useful for objects with large on-disk footprints, such as simulation output."], "extent": [5684, 5918]}, {"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 0, "text": [" ", {"scheme": "Image", "value": "/images/render/mug/packed/HoudiniGeometryRenderWorkflow.jpg", "type": "img", "text": ""}], "role": "item", "extent": [5918, 5992], "body": [], "container": true, "attrs": {"display": "left full"}}, {"ext": null, "type": "fig", "indent": 0, "text": [" ", {"scheme": "Image", "value": "/images/render/mug/packed/PackedPrimRenderWorkflow.jpg", "type": "img", "text": ""}], "role": "item", "extent": [6017, 6086], "body": [], "container": true, "attrs": {"display": "left full"}}, {"ext": null, "type": "fig", "indent": 0, "text": [" ", {"scheme": "Image", "value": "/images/render/mug/packed/BasicPackedDiskPrimRenderWorkflow.jpg", "type": "img", "text": ""}], "role": "item", "extent": [6111, 6189], "body": [], "container": true, "attrs": {"display": "left full"}}], "container": true, "role": "item_group"}]}, {"level": 4, "id": "packeddiskseq", "container": true, "type": "h", "indent": 0, "text": ["Packed Disk Sequence primitives"], "extent": [6215, 6271], "body": [{"type": "para", "indent": 0, "text": ["Packed Disk Sequence (PDS) primitives are similar to Packed Disk primitives (see above), but the primitive references a sequence of geometry filenames and an index into the file sequence. When Mantra loads the sequence primitive as part of the scene, it knows the full sequence (instead of just having the geometry for the current frame), so it can interpolate between frames for motion blur. In this way, Packed Disk Sequence primitives are a simple way to instance animated geometry (in the form of per-frame geometry files) efficiently at render time with motion blur."], "extent": [6271, 6845]}, {"type": "para", "indent": 0, "text": ["To import an animated sequence as a PDS, use a ", {"scheme": "Node", "value": "/nodes/sop/file", "type": "link", "text": ["File SOP"], "fullpath": "/nodes/sop/file.html"}, ". Set the ", {"type": "ui", "text": ["Load"]}, " parameter to ", {"type": "ui", "text": ["Packed Disk Sequence"]}, ". Click the ", {"scheme": "Icon", "value": "BUTTONS/chooser_file", "type": "link", "text": "", "fullpath": "/model/BUTTONS/chooser_file.html"}, " file chooser icon next to the ", {"type": "ui", "text": ["Geometry File"]}, " parameter and choose the geometry sequence to load."], "extent": [6845, 7113]}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [7113, 7119], "body": [{"type": "para", "indent": 4, "text": ["When you are loading a PDS, the ", {"type": "code", "text": ["$F"]}, " in the ", {"type": "ui", "text": ["Geometry File"]}, " pattern is interpolated between the values in the ", {"type": "ui", "text": ["Frame Range"]}, " parameter (it does not refer to the current frame as usual). We use ", {"type": "code", "text": ["$F"]}, " here for consistency with the other modes, so the file chooser works as you expect."], "extent": [7119, 7409]}], "container": true}], "container": true, "role": "item_group"}, {"type": "para", "indent": 0, "text": ["The ", {"type": "ui", "text": ["Sequence Index"]}, " parameter on the File SOP sets the (floating point) frame to use in the animated sequence. The default is ", {"type": "code", "text": ["$FF - 1"]}, ". You can edit the index on an existing PDS primitive using the ", {"scheme": "Node", "value": "/nodes/sop/packeddiskedit", "type": "link", "text": ["Packed Disk Edit SOP"], "fullpath": "/nodes/sop/packeddiskedit.html"}, "."], "extent": [7409, 7660]}, {"type": "para", "indent": 0, "text": ["Packed disk primitives automatically cycle when the rendered frame is outside the animation\u2019s frame range. You can change this by setting the ", {"type": "ui", "text": ["Wrap Mode"]}, " on the File SOP to one of ", {"type": "ui", "text": ["Clamp"]}, ", ", {"type": "ui", "text": ["Cycle"]}, ", ", {"type": "ui", "text": ["Mirror"]}, ", or ", {"type": "ui", "text": ["Strict"]}, ":"], "extent": [7660, 7892]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Cycle: Automatically wraps the sample index to the valid range (the default behavior). "], "extent": [7892, 7983]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Clamp: Clamps out of range index samples to the valid range. For example, if the valid frame range is 1-5, frame numbers greater than 5 will stick at frame 5."], "extent": [7983, 8145]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Mirror: Wraps by reversing in a zig-zag or ping-pong style."], "extent": [8145, 8208]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Strict: Gives empty geometry outside the valid frame range."], "extent": [8208, 8272]}], "container": true}]}, {"level": 4, "id": "fragments", "container": true, "type": "h", "indent": 0, "text": ["Packed fragments"], "extent": [8272, 8309], "body": [{"type": "para", "indent": 0, "text": ["When you pack geometry that includes a ", {"type": "code", "text": ["name"]}, " attribute, each piece of geometry that shares the same ", {"type": "code", "text": ["name"]}, " value becomes a ", {"type": "em", "text": ["packed fragment"]}, " primitive containing a reference to the original geometry. Each fragment shares the same geometry, but refers to a subset of the geometry. If you unpack a fragment, only that part of the original model is copied into memory."], "extent": [8309, 8678]}, {"type": "para", "indent": 0, "text": ["Packed fragment primitives are ideal for representing many pieces of a complete model, especially when each fragment will receive some unique transformation, such as in a rigid body simulation."], "extent": [8678, 8873]}, {"type": "para", "indent": 0, "text": [{"scheme": "Image", "value": "/images/render/mug/packed/BasicPackedFragmentUpdate.jpg", "type": "img", "text": ""}], "extent": [8873, 8938]}, {"type": "para", "indent": 0, "text": ["Because each fragment is just a reference to the original geometry, it is very efficient to use fragments when you have a large number of them. However, if you delete many of the fragments, their use can become more inefficient than using real geometry, because Houdini continues to keep the entire original model in memory. With real geometry, memory usage would be high at first, but would decrease as you delete parts of the geometry. You can try getting the best of both worlds by unpacking the fragments when you have only a few remaining."], "extent": [8938, 9485]}]}]}, {"level": 3, "id": null, "container": true, "type": "h", "indent": 0, "text": ["How to"], "extent": [9485, 9498], "body": [{"type": "task_group", "body": [{"ext": null, "type": "task", "indent": 0, "text": ["Convert SOP geometry into a packed primitive"], "role": "item", "extent": [9498, 9551], "body": [{"type": "para", "indent": 4, "text": ["Use the ", {"scheme": "Node", "value": "/nodes/sop/pack", "type": "link", "text": ["Pack SOP"], "fullpath": "/nodes/sop/pack.html"}, ".\n    The Pack node can create a new primitive with all the input geometry, or separate packed primitives based on the value of an attribute (such as ", {"type": "code", "text": ["name"]}, ", as created by ", {"scheme": null, "value": "/shelf/shatter", "type": "link", "text": ["Shatter"], "fullpath": "/shelf/shatter.html"}, ")."], "extent": [9551, 9787]}], "container": true}, {"ext": null, "type": "task", "indent": 0, "text": ["Extract a ", {"type": "q", "text": ["sub-primitive"]}, " from inside a packed primitive"], "role": "item", "extent": [9787, 9851], "body": [{"type": "para", "indent": 4, "text": ["Use the ", {"scheme": "Node", "value": "/nodes/sop/unpack", "type": "link", "text": ["Unpack SOP"], "fullpath": "/nodes/sop/unpack.html"}, "."], "extent": [9851, 9898]}], "container": true}, {"ext": null, "type": "task", "indent": 0, "text": ["Import geometry from a dynamics network as a packed primitive"], "role": "item", "extent": [9898, 9967], "body": [{"type": "para", "indent": 4, "text": ["The ", {"scheme": "Node", "value": "/nodes/sop/dopimport", "type": "link", "text": ["DOP Import SOP"], "fullpath": "/nodes/sop/dopimport.html"}, " has an option to import ", {"type": "code", "text": ["Geometry"]}, " data from a dynamics network as a packed primitive."], "extent": [9967, 10099]}], "container": true}, {"ext": null, "type": "task", "indent": 0, "text": ["Access attributes on packed geometry in a VEX shader"], "role": "item", "extent": [10099, 10159], "body": [{"type": "para", "indent": 4, "text": ["You can use the ", {"scheme": "Vex", "value": "/vex/functions/renderstate", "type": "link", "text": "", "fallback_text": "renderstate()", "fullpath": "/vex/functions/renderstate.html"}, " VEX function to get the value of attributes on packed geometry. For example, if the packed geometry has a ", {"type": "code", "text": ["Cd"]}, " attribute, you can use ", {"type": "code", "text": ["renderstate(\"packed:Cd\", PackedCd)"]}, "."], "extent": [10159, 10370]}], "container": true}], "container": true, "role": "item_group"}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [10370, 10376], "body": [{"type": "para", "indent": 4, "text": ["You cannot set/use ", {"scheme": null, "value": "/model/attributes", "type": "link", "text": ["primitive attributes"], "fullpath": "/model/attributes.html"}, " on the geometry other than the ", {"type": "code", "text": ["material"]}, " attribute (which Houdini treats as a special case).\n    In general, primitive-level attributes will not work since Houdini treats packed geometry like a single primitive with a single point."], "extent": [10376, 10675]}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 3, "id": "render", "container": true, "type": "h", "indent": 0, "text": ["Rendering"], "extent": [10675, 10700], "body": [{"type": "para", "indent": 0, "text": ["Packed primitives are extremely useful for rendering in Mantra. They let you generate IFDs,  render faster, and use less memory and disk space. "], "extent": [10700, 10848]}, {"level": 4, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Material assignment"], "extent": [10848, 10876], "body": [{"type": "para", "indent": 0, "text": ["With standard geometry, you can assign materials at two levels:"], "extent": [10876, 10942]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["At the object level, in the ", {"scheme": "Node", "value": "/nodes/obj/geo", "type": "link", "text": ["Geometry node"], "fullpath": "/nodes/obj/geo.html"}, "'s parameters."], "extent": [10942, 11015], "body": [], "container": true, "attrs": {"glyph": "fa-cube"}}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["At the geometry (SOPs) level, using the ", {"scheme": "Node", "value": "/nodes/sop/material", "type": "link", "text": ["Material node"], "fullpath": "/nodes/sop/material.html"}, " to set the ", {"type": "code", "text": ["material"]}, " attribute on certain primitives. This overrides the object material for the primitives that have it."], "extent": [11036, 11235], "body": [], "container": true, "attrs": {"glyph": "fa-th-large"}}], "container": true}, {"type": "para", "indent": 0, "text": ["When Houdini generates the scene description (IFD) file for rendering, it checks the object and geometry attributes for material assignments, so it knows which shaders to include in the IFD."], "extent": [11260, 11452]}, {"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 0, "text": [" ", {"scheme": "Image", "value": "/images/render/mug/packed/PackedPrimitiveForRender-01.jpg", "type": "img", "text": ""}], "role": "item", "extent": [11452, 11524], "body": [], "container": true, "attrs": {"display": "left full"}}], "container": true, "role": "item_group"}, {"type": "para", "indent": 0, "text": ["When you use packed primitives, there is a third possible level of material assignment:"], "extent": [11549, 11638]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Material attributes on the embedded geometry inside packed primitives. These override the ", {"type": "q", "text": ["higher"]}, " levels (primitive attributes and object materials)."], "extent": [11638, 11791], "body": [], "container": true, "attrs": {"glyph": "fa-th"}}], "container": true}, {"type": "para", "indent": 0, "text": ["However, when Houdini generates the IFD, it does not look in the embedded geometry (which might be a very large file that would be slow to scan through). As a result, Houdini does not know the embedded geometry\u2019s material attributes, and will not know to include the shaders in the IFD. Only when Mantra unpacks the primitives at render time will it find out that it may not have the shaders it needs."], "extent": [11810, 12213]}, {"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 0, "text": [" ", {"scheme": "Image", "value": "/images/render/mug/packed/PackedPrimitiveForRender-02.jpg", "type": "img", "text": ""}], "role": "item", "extent": [12213, 12285], "body": [], "container": true, "attrs": {"display": "left full"}}], "container": true, "role": "item_group"}, {"type": "para", "indent": 0, "text": ["To work around this problem, you can tell Houdini to include ", {"type": "em", "text": ["all"]}, " shaders in the scene in the IFD, regardless of whether they are assigned at the object or geometry levels. Turn on ", {"type": "ui", "text": ["Save all SHOPs"]}, " on the ", {"scheme": "Node", "value": "/nodes/out/ifd", "type": "link", "text": ["Mantra render node"], "fullpath": "/nodes/out/ifd.html"}, ". (This will increase the on-disk size of your IFD by a small amount). As long as you load the shaders that are needed by packed primitives into the scene, they will be available at render time."], "extent": [12310, 12747]}, {"type": "fig_group", "body": [{"ext": null, "type": "fig", "indent": 0, "text": [" ", {"scheme": "Image", "value": "/images/render/mug/packed/PackedPrimitiveForRender-03.jpg", "type": "img", "text": ""}], "role": "item", "extent": [12747, 12819], "body": [], "container": true, "attrs": {"display": "left full"}}], "container": true, "role": "item_group"}, {"type": "tip_group", "body": [{"type": "tip", "indent": 0, "role": "item", "extent": [12844, 12849], "body": [{"type": "para", "indent": 4, "text": ["For information on how to assign shaders and override shading parameters inside packed geometry, see ", {"scheme": null, "value": "/shade/stylesheets", "type": "link", "text": ["material style sheets"], "fullpath": "/shade/stylesheets.html"}, "."], "extent": [12849, 13000]}], "container": true}], "container": true, "role": "item_group"}]}, {"level": 4, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Displacement and subdivision surfaces"], "extent": [13000, 13046], "body": [{"type": "para", "indent": 0, "text": ["Houdini performs displacement shading and subdivision surface rendering the same way for packed geometry as for standard geometry. However, if you are primarily using packed geometry for instancing, you need to think about ", {"type": "em", "text": ["dicing"]}, "."], "extent": [13046, 13281]}, {"type": "para", "indent": 0, "text": ["Before rendering a displaced or subdivided surface, Mantra ", {"type": "q", "text": ["dices"]}, " the geometry into smaller primitives until there is one primitive for every pixel (when shading quality is set to ", {"type": "code", "text": ["1"]}, "). This means that it dices objects closer to the camera more than objects in the distance (which have less pixel coverage)."], "extent": [13281, 13591]}, {"type": "para", "indent": 0, "text": ["When instancing using packed geometry, this can cause a problem. The benefit of instancing is that geometry is shared across all instances. However, if you add displacements or subdivision rendering, Mantra must load and dice each object individually, which means the geometry is no longer being shared."], "extent": [13591, 13896]}, {"type": "para", "indent": 0, "text": ["To avoid this problem, you can add the ", {"scheme": "Mantra", "value": "/props/mantra#vm_sharedisplace", "type": "link", "text": "", "fallback_text": "vm_sharedisplace", "fullpath": "/props/mantra.html#vm_sharedisplace", "fragment": "#vm_sharedisplace"}, " render property to the object containing your instances. Turning this parameter on will tell Mantra to:"], "extent": [13896, 14066]}, {"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": ["Use the highest level of dicing necessary for the scene on one instance, and then"], "extent": [14066, 14155]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": ["Share that diced geometry between all instances"], "extent": [14155, 14206]}], "container": true}, {"type": "para", "indent": 0, "text": ["This means that objects that are far away will get ", {"type": "q", "text": ["too much"]}, " detail, which could potentially cause slowdowns. However, the benefits of preserving instancing likely outweigh any downside."], "extent": [14206, 14395]}, {"type": "para", "indent": 0, "text": ["In the worst case, if ", {"type": "q", "text": ["incorrect"]}, " dicing levels cause problems, you can split the instances between two objects based on distance from the camera. In this case, the highest dicing level is computed separately for near and far."], "extent": [14395, 14623]}, {"type": "para", "indent": 0, "text": ["Alternatively, you could unpack instances close to the camera, removing them from the ", {"type": "q", "text": ["highest necessary dicing level"]}, " calculation."], "extent": [14623, 14757]}]}, {"level": 4, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Attributes"], "extent": [14757, 14776], "body": [{"type": "para", "indent": 0, "text": [{"type": "strong", "text": ["Disk and in-memory"]}, " packed primitive instances are simply pointers to the same file or memory, so each instance cannot have individual attribute values (except the ", {"type": "code", "text": ["material"]}, " and ", {"type": "code", "text": ["vel"]}, " (velocity) attributes which are specifically hacked to work, see below)."], "extent": [14776, 15037]}, {"type": "para", "indent": 0, "text": [{"type": "strong", "text": ["Packed fragment"]}, " instances ", {"type": "em", "text": ["can"]}, " have individual attributes because they are coalesced, but this also means that they are less efficient than on-disk or in-memory packed primitives."], "extent": [15037, 15221]}, {"type": "para", "indent": 0, "text": [{"type": "strong", "text": ["Alembic primitive"]}, " instances cannot have individual attribute values. However, there is an option to ", {"type": "q", "text": ["unshare"]}, " Alembic primitives in Mantra. This uses a lot more memory but allows you to have individual attributes on Alembic primitive instances at render time."], "extent": [15221, 15484]}, {"type": "para", "indent": 0, "text": ["Mantra creates a tree of virtual Mantra objects for packed primitives, and copies the ", {"type": "code", "text": ["material"]}, " attribute down to each virtual object in the tree (if they do not have a ", {"type": "code", "text": ["material"]}, " attribute of their own). In this way, materials on the Geometry object are properly applied to packed primitives inside. Similarly, the ", {"type": "code", "text": ["vel"]}, " (velocity) attribute is ", {"type": "em", "text": ["added"]}, " down through the virtual object tree, so motion blur will work properly."], "extent": [15484, 15913]}, {"type": "para", "indent": 0, "text": ["Primitive attributes on packed primitives are copied to object properties on the virtual Mantra object. You can access them in shader code using the ", {"scheme": "Node", "value": "/nodes/vop/renderstate", "type": "link", "text": ["Render State VOP"], "fullpath": "/nodes/vop/renderstate.html"}, " or ", {"scheme": "Vex", "value": "/vex/functions/renderstate", "type": "link", "text": "", "fallback_text": "renderstate()", "fullpath": "/vex/functions/renderstate.html"}, " VEX function."], "extent": [15913, 16138]}, {"type": "para", "indent": 0, "text": ["If you have a primitive ", {"type": "code", "text": ["material"]}, " attribute ", {"type": "em", "text": ["inside"]}, " a packed primitive, Houdini will not look inside the primitive to determine that it needs to include that material in the file it sends to Mantra. You can fix this (at the expense of a larger render file) by turning on the ", {"type": "ui", "text": ["Declare all SHOPs"]}, " option, which tells Houdini to include all materials in the render file."], "extent": [16138, 16511]}, {"type": "para", "indent": 0, "text": ["When Mantra renders packed primitive ", {"type": "em", "text": ["fragments"]}, ", it copies attributes from the packed primitive onto the geometry, so velocity blur on fragments will work. Other packed primitive types do not work this way since they are rendered as instances."], "extent": [16511, 16758]}]}]}]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [615, 627], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Display As"], "extent": [627, 640], "body": [{"type": "para", "indent": 4, "text": ["How packed primitives should be displayed in the viewport."], "extent": [640, 704]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Create Path Attribute"], "extent": [704, 727], "body": [{"type": "para", "indent": 4, "text": ["Specifies whether a path attribute is added to the packed primitives."], "extent": [747, 822]}], "container": true, "attrs": {"id": "createpath"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Path Attribute"], "extent": [822, 838], "body": [{"type": "para", "indent": 4, "text": ["The path attribute value assigned to the newly created packed primitive. If this field is disabled or left blank, no path attribute will be created."], "extent": [852, 1006]}], "container": true, "attrs": {"id": "path"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Pack By Name"], "extent": [1006, 1020], "body": [{"type": "para", "indent": 4, "text": ["The SOP\u2019s geometry is divided into one or more packed fragments. For\n    every unique value of the name attribute, a packed primitive will be\n    created with only the primitives or points that have that attribute value."], "extent": [1020, 1250]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Name Attribute"], "extent": [1250, 1266], "body": [{"type": "para", "indent": 4, "text": ["Specifies the primitive or point, string or integer attribute used to\n    identify primitives belonging to each fragment.  If a point attribute\n    is specified, only the points will be packed."], "extent": [1266, 1470]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Create Packed Fragments"], "extent": [1470, 1495], "body": [{"type": "para", "indent": 4, "text": ["Specifies Packed Fragment primitives should be created instead of Packed\n    Geometry primitives.  This only works with primitive string attributes."], "extent": [1520, 1674]}, {"type": "tip_group", "body": [{"type": "tip", "indent": 4, "role": "item", "extent": [1674, 1683], "body": [{"type": "para", "indent": 8, "text": ["Packed Fragment primitives are more efficient if the final rendered\n        geometry has many unique pieces.  Packed Geometry primitives are more\n        efficient if the final rendered geometry has many copies of the same\n        piece."], "extent": [1683, 1931]}], "container": true}], "container": true, "role": "item_group"}], "container": true, "attrs": {"id": "packedfragments"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Pivot Location"], "extent": [1931, 1947], "body": [{"type": "para", "indent": 4, "text": ["Specifies how to initialize the offset for the point referenced by the\n    packed primitive."], "extent": [1947, 2045]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Transfer Attributes"], "extent": [2045, 2066], "body": [{"type": "para", "indent": 4, "text": ["Specifies a list of attributes to transfer to the packed geometry."], "extent": [2095, 2167]}], "container": true, "attrs": {"id": "transfer_attributes"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Transfer Groups"], "extent": [2167, 2184], "body": [{"type": "para", "indent": 4, "text": ["Specifies a list of groups to transfer to the packed geometry."], "extent": [2209, 2277]}], "container": true, "attrs": {"id": "transfer_groups"}, "role": "item"}], "container": true, "role": "item_group"}], "text": "Parameters"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [2277, 2286], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/file", "type": "link", "text": "", "fullpath": "/nodes/sop/file.html"}], "extent": [2286, 2305]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/unpack", "type": "link", "text": "", "fullpath": "/nodes/sop/unpack.html"}], "extent": [2305, 2325]}, {"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/sop/packededit", "type": "link", "text": "", "fullpath": "/nodes/sop/packededit.html"}], "extent": [2325, 2349]}], "container": true}], "text": "Related"}], "title": ["Pack"], "summary": ["Packs geometry into an embedded primitive."], "included": ["/model/packed"]}