{"type": "root", "attrs": {"type": "node", "context": "cop", "internal": "wrangle", "icon": "COP/wrangle", "version": null, "namespace": null}, "body": [{"level": 0, "type": "title", "indent": 0, "text": ["Wrangle"], "extent": [74, 86]}, {"type": "summary", "indent": 0, "text": ["Runs a VEX snippet to modify layer values."], "extent": [86, 137]}, {"type": "para", "indent": 0, "text": ["This is a very powerful, low-level node that lets experts who are\nfamiliar with VEX tweak pixel values using code."], "extent": [137, 253]}, {"type": "para", "indent": 0, "text": ["This node corresponds to the ", {"scheme": "Node", "value": "/nodes/sop/volumewrangle", "type": "link", "text": ["Volume Wrangle\nSOP"], "fullpath": "/nodes/sop/volumewrangle.html"}, ", but automatically converts the incoming\nlayers to bound volumes."], "extent": [253, 393]}, {"type": "para", "indent": 0, "text": ["All of the layers are bound into a single geometry input ", {"type": "code", "text": ["0"]}, ".\nAdditional geometry thus needs to use higher input numbers."], "extent": [393, 516]}, {"type": "para", "indent": 0, "text": [{"type": "code", "text": ["@P"]}, " can be used to get the current world position of the processed\npixel."], "extent": [516, 592]}, {"type": "note_group", "body": [{"type": "note", "indent": 0, "role": "item", "extent": [592, 598], "body": [{"type": "para", "indent": 4, "text": ["While VEX is considerably more accessible than OpenCL, it is still\n    encouraged to use the OpenCL COP rather than a Wrangle.  A wrangle\n    should be used where you need access to high-level geometry\n    functions.  Wrangles are CPU nodes so can considerably slow down\n    networks."], "extent": [598, 888]}], "container": true}], "container": true, "role": "item_group"}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Syntax"], "extent": [888, 901], "body": [{"type": "include_group", "body": [{"ext": "wrangle_syntax", "type": "include", "indent": 0, "role": "item", "extent": [901, 928]}], "container": true, "role": "item_group"}]}, {"level": 2, "id": "values", "container": true, "type": "h", "indent": 0, "text": ["Reading and modifying the pixel value"], "extent": [928, 981], "body": [{"type": "para", "indent": 0, "text": ["The current pixel value in a layer is available as ", {"type": "code", "text": ["@", {"type": "var", "text": ["layer_name"]}]}, ".\nYou can read this variable to get the current value, and assign it to change the value."], "extent": [981, 1141]}, {"type": "para", "indent": 0, "text": ["These will have the same VEX type as the layer - so a UV layer will\nbe of type ", {"type": "code", "text": ["vector2"]}, " and have a ", {"type": "code", "text": [".x"]}, " and ", {"type": "code", "text": [".y"]}], "extent": [1141, 1256]}]}, {"level": 1, "id": "parameters", "container": true, "type": "parameters_section", "indent": 0, "role": "section", "extent": [1256, 1268], "body": [{"type": "include_group", "body": [{"ext": "pointwrangle#snippet", "type": "include", "indent": 0, "role": "item", "extent": [1268, 1305]}], "container": true, "role": "item_group"}, {"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Volumes to Write to"], "extent": [1305, 1326], "body": [{"type": "para", "indent": 4, "text": ["Only modify layers if their names match this pattern.\n    The default pattern allows any layer to be modified.\n    You can speed up the node by only listing layers that are ", {"type": "em", "text": ["actually"]}, " modified by the snippet."], "extent": [1355, 1573]}, {"type": "para", "indent": 4, "text": ["For example, in the following snippet, only the ", {"type": "code", "text": ["density"]}, " layer is modified.\n    The ", {"type": "code", "text": ["temperature"]}, " layer is not modified, only read."], "extent": [1573, 1715]}, {"lang": "vex", "type": "pre", "indent": 4, "text": ["\n    @density = @temperature;\n    "], "extent": [1715, 1770]}, {"type": "para", "indent": 4, "text": ["However, for obscure reasons, the node will both modify ", {"type": "code", "text": ["density"]}, " and ", {"type": "em", "text": ["copy"]}, " ", {"type": "code", "text": ["temperature"]}, ".\n    This uses time and memory.\n    To prevent this, you could set this parameter to ", {"type": "code", "text": ["density"]}, " to prevent the node\n    from copying ", {"type": "code", "text": ["temperature"]}, ".\n    Of course, this requires that you explicitly manage the list of\n    writable layers."], "extent": [1770, 2112]}], "container": true, "attrs": {"id": "vex_exportlist"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Enforce Prototypes"], "extent": [16, 36], "body": [{"type": "para", "indent": 4, "text": ["Requires that you declare ", {"type": "code", "text": ["@"]}, " bindings in snippets as prototypes before using them. This applies to both attributes (for example ", {"type": "code", "text": ["@Cd"]}, ") and ", {"type": "q", "text": ["convenience"]}, " bindings such as ", {"type": "code", "text": ["@ptnum"]}, " and ", {"type": "code", "text": ["@Frame"]}, ". For example:"], "extent": [36, 248]}, {"lang": "vex", "type": "pre", "indent": 4, "text": ["\n    // Declare bindings\n    int @ptnum;\n    float @Frame;\n    vector @Cd;\n\n    // Use bindings after declaration\n    int pointnum = @ptnum;\n    float red = @Cd[0] / @Frame;\n    "], "extent": [248, 447]}, {"type": "para", "indent": 4, "text": ["Automatic binding with the ", {"type": "code", "text": ["@"]}, " syntax can be convenient, but as your scene becomes more complex there is the risk that a typo in an ", {"type": "code", "text": ["@"]}, " binding will silently just bind a non-existent attribute."], "extent": [447, 646]}], "container": true, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Evaluation Node Path"], "extent": [2152, 2174], "body": [{"type": "para", "indent": 4, "text": ["VEX functions like ", {"type": "code", "text": ["ch()"]}, " usually evaluate with respect to this node.\n    Providing a path here can override where the path search starts\n    from.  This is useful for embedding in a digital asset where you\n    would like the top level digital asset to be the search root."], "extent": [2196, 2483]}], "container": true, "attrs": {"id": "vex_cwdpath"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Export Parameters"], "extent": [2483, 2502], "body": [{"type": "para", "indent": 4, "text": ["This pattern can be used to override\n    the export option on the VEX shader to avoid writing to \n    certain volumes.  The pattern matches the VEX parameter, not\n    the bound volume.  The volume will still be bound for\n    reading."], "extent": [2531, 2774]}], "container": true, "attrs": {"id": "vex_outputmask"}, "role": "item"}], "container": true, "role": "item_group"}, {"level": 2, "id": null, "container": true, "type": "h", "indent": 0, "text": ["Number of Inputs"], "extent": [2774, 2797], "body": [{"type": "parameters_item_group", "body": [{"type": "parameters_item", "indent": 0, "text": ["Type"], "extent": [2797, 2804], "body": [{"type": "para", "indent": 4, "text": ["The type of the input.  Layer inputs will be bound to a volume of\n    the provided name.  Geometry inputs will become extra geometry\n    inputs accessible by the Input Index."], "extent": [2820, 3004]}, {"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["Mono"], "extent": [3004, 3014], "body": [{"type": "para", "indent": 8, "text": ["A Mono layer corresponding to a float volume."], "extent": [3014, 3077]}], "container": true}, {"type": "dt", "indent": 4, "text": ["UV"], "extent": [3077, 3085], "body": [{"type": "para", "indent": 8, "text": ["A UV layer corresponding to a vector2 volume."], "extent": [3085, 3148]}], "container": true}, {"type": "dt", "indent": 4, "text": ["RGB"], "extent": [3148, 3157], "body": [{"type": "para", "indent": 8, "text": ["An RGB layer corresponding to a vector volume."], "extent": [3157, 3221]}], "container": true}, {"type": "dt", "indent": 4, "text": ["RGBA"], "extent": [3221, 3231], "body": [{"type": "para", "indent": 8, "text": ["An RGBA layer corresponding to a vector4 volume."], "extent": [3231, 3297]}], "container": true}, {"type": "dt", "indent": 4, "text": ["ID"], "extent": [3297, 3305], "body": [{"type": "para", "indent": 8, "text": ["An ID layer corresponding to a int volume."], "extent": [3305, 3365]}], "container": true}, {"type": "dt", "indent": 4, "text": ["Geometry"], "extent": [3365, 3379], "body": [{"type": "para", "indent": 8, "text": ["A geoemtry input that will be bound to a given internal input."], "extent": [3379, 3464]}], "container": true}], "container": true}], "container": true, "attrs": {"id": "type#"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Binding Name"], "extent": [3464, 3478], "body": [{"type": "para", "indent": 4, "text": ["The name of the layer. This is the name it is given in the binding\n    and how it can be referred to from the VEX snippet."], "extent": [3495, 3632]}], "container": true, "attrs": {"id": "layer#"}, "role": "item"}, {"type": "parameters_item", "indent": 0, "text": ["Input Index"], "extent": [3632, 3645], "body": [{"type": "para", "indent": 4, "text": ["Geometry inputs can be referred to by this index.  For example, if\n    it is ", {"type": "code", "text": ["2"]}, ", then to read the number of points ", {"type": "code", "text": ["npoints(2)"]}, " would be\n    used.  ", {"type": "code", "text": ["0"]}, " is reserved for the implicit layer input."], "extent": [3665, 3874]}], "container": true, "attrs": {"id": "geoinput#"}, "role": "item"}], "container": true, "role": "item_group"}]}], "text": "Parameters"}, {"level": 1, "id": "inputs", "container": true, "type": "inputs_section", "indent": 0, "role": "section", "extent": [3874, 3882], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["input1"], "extent": [3882, 3894], "body": [{"type": "para", "indent": 8, "text": ["Inputs to send into the wrangle."], "extent": [3894, 3936]}], "container": true}], "container": true}], "text": "Inputs"}, {"level": 1, "id": "outputs", "container": true, "type": "outputs_section", "indent": 0, "role": "section", "extent": [3936, 3945], "body": [{"type": "dt_group", "body": [{"type": "dt", "indent": 4, "text": ["output1"], "extent": [3945, 3958], "body": [{"type": "para", "indent": 8, "text": ["The inputs as processed by the wrangle."], "extent": [3958, 4007]}], "container": true}], "container": true}], "text": "Outputs"}, {"level": 1, "id": "related", "container": true, "type": "related_section", "indent": 0, "role": "section", "extent": [4007, 4016], "body": [{"type": "bullet_group", "body": [{"blevel": 2, "type": "bullet", "indent": 0, "text": [{"scheme": "Node", "value": "/nodes/cop/opencl", "type": "link", "text": "", "fullpath": "/nodes/cop/opencl.html"}], "extent": [4016, 4037]}], "container": true}], "text": "Related"}], "title": ["Wrangle"], "summary": ["Runs a VEX snippet to modify layer values."], "included": ["/vex/_enforce_prototypes"]}